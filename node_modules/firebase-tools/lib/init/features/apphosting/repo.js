"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listAppHostingConnections = exports.getOrCreateRepository = exports.getOrCreateConnection = exports.createConnection = exports.linkGitHubRepository = exports.parseConnectionName = void 0;
const clc = require("colorette");
const gcb = require("../../../gcp/cloudbuild");
const rm = require("../../../gcp/resourceManager");
const poller = require("../../../operation-poller");
const utils = require("../../../utils");
const api_1 = require("../../../api");
const error_1 = require("../../../error");
const prompt_1 = require("../../../prompt");
const getProjectNumber_1 = require("../../../getProjectNumber");
const APPHOSTING_CONN_PATTERN = /.+\/apphosting-github-conn-.+$/;
const APPHOSTING_OAUTH_CONN_NAME = "apphosting-github-oauth";
const CONNECTION_NAME_REGEX = /^projects\/(?<projectId>[^\/]+)\/locations\/(?<location>[^\/]+)\/connections\/(?<id>[^\/]+)$/;
function parseConnectionName(name) {
    const match = name.match(CONNECTION_NAME_REGEX);
    if (!match || typeof match.groups === undefined) {
        return;
    }
    const { projectId, location, id } = match.groups;
    return {
        projectId,
        location,
        id,
    };
}
exports.parseConnectionName = parseConnectionName;
const gcbPollerOptions = {
    apiOrigin: api_1.cloudbuildOrigin,
    apiVersion: "v2",
    masterTimeout: 25 * 60 * 1000,
    maxBackoff: 10000,
};
function extractRepoSlugFromUri(remoteUri) {
    const match = /github.com\/(.+).git/.exec(remoteUri);
    if (!match) {
        return undefined;
    }
    return match[1];
}
function generateRepositoryId(remoteUri) {
    var _a;
    return (_a = extractRepoSlugFromUri(remoteUri)) === null || _a === void 0 ? void 0 : _a.replaceAll("/", "-");
}
function generateConnectionId() {
    const randomHash = Math.random().toString(36).slice(6);
    return `apphosting-github-conn-${randomHash}`;
}
async function linkGitHubRepository(projectId, location) {
    var _a, _b, _c;
    utils.logBullet(clc.bold(`${clc.yellow("===")} Set up a GitHub connection`));
    const existingConns = await listAppHostingConnections(projectId);
    if (existingConns.length < 1) {
        const grantSuccess = await promptSecretManagerAdminGrant(projectId);
        if (!grantSuccess) {
            throw new error_1.FirebaseError("Insufficient IAM permissions to create a new connection to GitHub");
        }
        let oauthConn = await getOrCreateConnection(projectId, location, APPHOSTING_OAUTH_CONN_NAME);
        while (oauthConn.installationState.stage === "PENDING_USER_OAUTH") {
            oauthConn = await promptConnectionAuth(oauthConn);
        }
        const connectionId = generateConnectionId();
        const conn = await createConnection(projectId, location, connectionId, {
            authorizerCredential: (_a = oauthConn.githubConfig) === null || _a === void 0 ? void 0 : _a.authorizerCredential,
        });
        let refreshedConn = conn;
        while (refreshedConn.installationState.stage !== "COMPLETE") {
            refreshedConn = await promptAppInstall(conn);
        }
        existingConns.push(refreshedConn);
    }
    let { remoteUri, connection } = await promptRepositoryUri(projectId, existingConns);
    while (remoteUri === "") {
        await utils.openInBrowser("https://github.com/apps/google-cloud-build/installations/new");
        await (0, prompt_1.promptOnce)({
            type: "input",
            message: "Press ENTER once you have finished configuring your installation's access settings.",
        });
        const selection = await promptRepositoryUri(projectId, existingConns);
        remoteUri = selection.remoteUri;
        connection = selection.connection;
    }
    const { id: connectionId } = parseConnectionName(connection.name);
    await getOrCreateConnection(projectId, location, connectionId, {
        authorizerCredential: (_b = connection.githubConfig) === null || _b === void 0 ? void 0 : _b.authorizerCredential,
        appInstallationId: (_c = connection.githubConfig) === null || _c === void 0 ? void 0 : _c.appInstallationId,
    });
    const repo = await getOrCreateRepository(projectId, location, connectionId, remoteUri);
    utils.logSuccess(`Successfully linked GitHub repository at remote URI`);
    utils.logSuccess(`\t${remoteUri}`);
    return repo;
}
exports.linkGitHubRepository = linkGitHubRepository;
async function promptRepositoryUri(projectId, connections) {
    const remoteUriToConnection = {};
    for (const conn of connections) {
        const { location, id } = parseConnectionName(conn.name);
        const resp = await gcb.fetchLinkableRepositories(projectId, location, id);
        if (resp.repositories && resp.repositories.length > 0) {
            for (const repo of resp.repositories) {
                remoteUriToConnection[repo.remoteUri] = conn;
            }
        }
    }
    const choices = Object.keys(remoteUriToConnection).map((remoteUri) => ({
        name: extractRepoSlugFromUri(remoteUri) || remoteUri,
        value: remoteUri,
    }));
    choices.push({
        name: "Missing a repo? Select this option to configure your installation's access settings",
        value: "",
    });
    const remoteUri = await (0, prompt_1.promptOnce)({
        type: "list",
        message: "Which of the following repositories would you like to deploy?",
        choices,
    });
    return { remoteUri, connection: remoteUriToConnection[remoteUri] };
}
async function promptSecretManagerAdminGrant(projectId) {
    const projectNumber = await (0, getProjectNumber_1.getProjectNumber)({ projectId });
    const cbsaEmail = gcb.serviceAgentEmail(projectNumber);
    const alreadyGranted = await rm.serviceAccountHasRoles(projectId, cbsaEmail, ["roles/secretmanager.admin"], true);
    if (alreadyGranted) {
        return true;
    }
    utils.logBullet("To create a new GitHub connection, Secret Manager Admin role (roles/secretmanager.admin) is required on the Cloud Build Service Agent.");
    const grant = await (0, prompt_1.promptOnce)({
        type: "confirm",
        message: "Grant the required role to the Cloud Build Service Agent?",
    });
    if (!grant) {
        utils.logBullet("You, or your project administrator, should run the following command to grant the required role:\n\n" +
            "You, or your project adminstrator, can run the following command to grant the required role manually:\n\n" +
            `\tgcloud projects add-iam-policy-binding ${projectId} \\\n` +
            `\t  --member="serviceAccount:${cbsaEmail} \\\n` +
            `\t  --role="roles/secretmanager.admin\n`);
        return false;
    }
    await rm.addServiceAccountToRoles(projectId, cbsaEmail, ["roles/secretmanager.admin"], true);
    utils.logSuccess("Successfully granted the required role to the Cloud Build Service Agent!");
    return true;
}
async function promptConnectionAuth(conn) {
    utils.logBullet("You must authorize the Cloud Build GitHub app.");
    utils.logBullet("Sign in to GitHub and authorize Cloud Build GitHub app:");
    const { url, cleanup } = await utils.openInBrowserPopup(conn.installationState.actionUri, "Authorize the GitHub app");
    utils.logBullet(`\t${url}`);
    await (0, prompt_1.promptOnce)({
        type: "input",
        message: "Press Enter once you have authorized the app",
    });
    cleanup();
    const { projectId, location, id } = parseConnectionName(conn.name);
    return await gcb.getConnection(projectId, location, id);
}
async function promptAppInstall(conn) {
    utils.logBullet("Install the Cloud Build GitHub app to enable access to GitHub repositories");
    const targetUri = conn.installationState.actionUri.replace("install_v2", "direct_install_v2");
    utils.logBullet(targetUri);
    await utils.openInBrowser(targetUri);
    await (0, prompt_1.promptOnce)({
        type: "input",
        message: "Press Enter once you have installed or configured the Cloud Build GitHub app to access your GitHub repo.",
    });
    const { projectId, location, id } = parseConnectionName(conn.name);
    return await gcb.getConnection(projectId, location, id);
}
async function createConnection(projectId, location, connectionId, githubConfig) {
    const op = await gcb.createConnection(projectId, location, connectionId, githubConfig);
    const conn = await poller.pollOperation(Object.assign(Object.assign({}, gcbPollerOptions), { pollerName: `create-${location}-${connectionId}`, operationResourceName: op.name }));
    return conn;
}
exports.createConnection = createConnection;
async function getOrCreateConnection(projectId, location, connectionId, githubConfig) {
    let conn;
    try {
        conn = await gcb.getConnection(projectId, location, connectionId);
    }
    catch (err) {
        if (err.status === 404) {
            conn = await createConnection(projectId, location, connectionId, githubConfig);
        }
        else {
            throw err;
        }
    }
    return conn;
}
exports.getOrCreateConnection = getOrCreateConnection;
async function getOrCreateRepository(projectId, location, connectionId, remoteUri) {
    const repositoryId = generateRepositoryId(remoteUri);
    if (!repositoryId) {
        throw new error_1.FirebaseError(`Failed to generate repositoryId for URI "${remoteUri}".`);
    }
    let repo;
    try {
        repo = await gcb.getRepository(projectId, location, connectionId, repositoryId);
    }
    catch (err) {
        if (err.status === 404) {
            const op = await gcb.createRepository(projectId, location, connectionId, repositoryId, remoteUri);
            repo = await poller.pollOperation(Object.assign(Object.assign({}, gcbPollerOptions), { pollerName: `create-${location}-${connectionId}-${repositoryId}`, operationResourceName: op.name }));
        }
        else {
            throw err;
        }
    }
    return repo;
}
exports.getOrCreateRepository = getOrCreateRepository;
async function listAppHostingConnections(projectId) {
    const conns = await gcb.listConnections(projectId, "-");
    return conns.filter((conn) => APPHOSTING_CONN_PATTERN.test(conn.name) &&
        conn.installationState.stage === "COMPLETE" &&
        !conn.disabled);
}
exports.listAppHostingConnections = listAppHostingConnections;
